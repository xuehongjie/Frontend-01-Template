# 浏览器工作原理

## 有限状态机

- 每一个状态都是一个机器
  - 在每一个机器里，可以做计算、存储、输出
  - 所有的机器接受的输入都是一致的(字符串/数字/其他类型)
  - 状态机的每一个机器本身没有状态，每一个输入都对应一个输出，如果用函数来表示的话，它应该是纯函数(无副作用，不依赖环境)
- 每一个机器知道下一个状态
  - 每个机器都有确定的下一个状态(Moore)
  - 每个机器根据输入决定下一个状态(Mealy)
  ```
  // 函数参数就是输入
  function state(input) {
    // 处理每个状态的逻辑
    return next; // 返回值作为下一个状态
  }
  while(input) {
    state = state(input); // 把状态机的返回值作为下一个状态
  }
  ```

## 解析 HTML

### 1. 拆分文件

将 parseHTML 拆到单独的文件中

### 2. 创建状态机

### 3. 解析标签

- 开始标签
- 结束标签
- 自封闭标签

### 4. 创建元素

### 5. 处理属性

- 单引号
- 双引号
- 无引号

### 6. 构建 DOM 树

- 从标签构建 DOM 树的基本技巧是使用栈
- 遇到开始标签时创建元素并入栈，遇到结束标签时出栈
- 自封闭节点可视为入栈后立刻出栈
- 任何元素的父元素是它入栈前的栈顶

### 7. 文本节点

- 与自封闭标签类似
- 多个文本节点需要合并

## CSS

准备环境 `npm install css`

### 1. 收集 CSS 规则

- 遇到 style 标签时，把 CSS 规则保存起来
- 调用 CSS Parser 来分析 CSS 规则
- 研究 css 库分析 CSS 规则的格式

### 2. 添加调用

- 创建一个元素后，立即计算 CSS
- 理论上，当我们分析一个元素时，所有 CSS 规则已经收集完毕

### 3. 获取父元素序列

- 在 computeCSS 函数中，我们必须知道元素所有父元素才能判断元素与规则是否匹配
- 从上一步骤的 stack，可以获取本元素所有的父元素
- 因为我们首先获取的是 “当前元素”，所以我们获得和计算父元素匹配的顺序是从内向外(div div #myid)

### 4. 拆分选择器

- 选择器从当前元素向外排列
- 复杂选择器拆成针对单个元素的选择器，循环匹配父元素队列

### 5. 计算选择器与元素匹配

- 根据选择器的类型和元素属性计算是否与当前元素匹配

### 6. 生成 computed 属性

- 匹配选择器后应用到选择器的元素上，形成computedStyle

### 7. 确定规则覆盖关系

- CSS 规则根据 specificity 和后来优先规则覆盖
- specificity 是个四元数组(如[1, 1, 1, 1]，左边权重高)
- 一个 CSS 规则的 specificity 根据包含的简单选择器相加而成
